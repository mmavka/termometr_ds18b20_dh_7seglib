#include "EERTOS.h"


// Очереди задач, таймеров.
// Тип данных - указатель на функцию
volatile static TPTR	TaskQueue[TaskQueueSize + 1];	        // очередь указателей
volatile static struct {TPTR GoToTask; 			        // Указатель перехода
                        uint16_t Time;			        // Выдержка в мс
                       } MainTimer[MainTimerQueueSize + 1];     // Очередь таймеров


/**************************************************************************
*   Function name :   InitRTOS
*   Returns :         none       
*   Parameters :      none    
*   Purpose :         RTOS Подготовка. Очистка очередей        
****************************************************************************/
inline void InitRTOS(void)
{
  uint8_t index;

  for (index = 0; index != TaskQueueSize + 1; index++)  // Во все позиции записываем Idle
  {
    TaskQueue[index] = Idle;
  }
  
  for (index = 0; index != MainTimerQueueSize + 1; index++)// Обнуляем все таймеры.
  {
    MainTimer[index].GoToTask = Idle;
    MainTimer[index].Time = 0;
  }
}

/**************************************************************************
*   Function name :   Idle
*   Returns :                
*   Parameters :          
*   Purpose :         Пустая процедура - простой ядра.       
****************************************************************************/
inline void  Idle(void)
{
}

/**************************************************************************
*   Function name :   SetTask
*   Returns :         код ошибки       
*   Parameters :      1 - указатель на функцию    
*   Purpose :         Функция установки задачи в очередь       
****************************************************************************/
void SetTask(TPTR TS)
{

  uint8_t index = 0;
  uint8_t intState;

intState = __save_interrupt();
        __disable_interrupt();

  // Это бодояга вида ATOMIС RESTORSTATE только собственной выделки с закосом под
  // мультиплатформенность. Как видишь, тут SREG явно не указыватеся, он прописан в 
  // дефайнах. При переносе на другой микроконтроллер, например, на С51 мне только 
  // пару файлов поправить. А прерывания надо однозначно запретить. Ибо нужно
  // обеспечить атомарность операций. 

  // А вот и постановка задачи в очередь.
  while(TaskQueue[index] != Idle)                       // Прочесываем очередь задач на предмет свободной ячейки
  {                                                     // с значением Idle - конец очереди.
    index++;
    if (index == TaskQueueSize + 1)                     // Если очередь переполнена то выходим не солоно хлебавши
    {
      __restore_interrupt(intState);                    // Если мы не в прерывании, то разрешаем прерывания
      return;				                // Раньше функция возвращала код ошибки - очередь переполнена. Пока убрал.
    }
  }
                                                        // Если нашли свободное место, то
  TaskQueue[index] = TS;			        // Записываем в очередь задачу
  __restore_interrupt(intState);                        // И включаем прерывания если не в обработчике прерывания.
}


/**************************************************************************
*   Function name :   SetTimerTask
*   Returns :         Код ошибки       
*   Parameters :      1 - указатель на функцию, 2 - Время выдержки в тиках системного таймера    
*   Purpose :         Функция установки задачи по таймеру       
****************************************************************************/
void SetTimerTask(TPTR TS, uint16_t NewTime)
{
  uint8_t index;
  uint8_t intState;

  intState = __save_interrupt();
             __disable_interrupt();

  for (index = 0; index != MainTimerQueueSize + 1; ++index)// Прочесываем очередь таймеров
  {
    if(MainTimer[index].GoToTask == TS)                 // Если уже есть запись с таким адресом
    {
      MainTimer[index].Time = NewTime;                  // Перезаписываем ей выдержку
      __restore_interrupt(intState);                    // Разрешаем прерывания если не были запрещены.
      return;	                                        // Выходим. Раньше был код успешной операции. Пока убрал
    }   
  }
          
  for (index = 0; index != MainTimerQueueSize + 1; ++index)// Если не находим похожий таймер, то ищем любой пустой	
  {
    if (MainTimer[index].GoToTask == Idle)		
    {
      MainTimer[index].GoToTask = TS;	                // Заполняем поле перехода задачи
      MainTimer[index].Time = NewTime;                  // И поле выдержки времени
      __restore_interrupt(intState);	                // Разрешаем прерывания
    return;				                // Выход. 
    }           
  }					                // тут можно сделать return c кодом ошибки - нет свободных таймеров
  __restore_interrupt(intState);	                // Разрешаем прерывания если не были запрещены.
}

/**************************************************************************
*   Function name :   DelTimerTask
*   Returns :         none       
*   Parameters :      1 - указатель на функцию    
*   Purpose :         Функция удаления задачи из очереди       
****************************************************************************/
void DelTimerTask(TPTR TS)
{
  uint8_t index;
  uint8_t intState;

  intState = __save_interrupt();
             __disable_interrupt();


  for (index = 0; index != MainTimerQueueSize + 1; ++index)//Прочесываем очередь таймеров
  {
    if(MainTimer[index].GoToTask == TS)                 // Если уже есть запись с таким адресом
    {
      MainTimer[index].GoToTask = Idle;                 // Пишем затычку
      MainTimer[index].Time = 0;
      __restore_interrupt(intState);                    // Разрешаем прерывания если не были запрещены.
      return;                                           // Выходим. Раньше был код успешной операции. Пока убрал
    }
  }                                                     // тут можно сделать return c кодом ошибки - нет свободных таймеров
  __restore_interrupt(intState);	                // Разрешаем прерывания если не были запрещены.
}

/**************************************************************************
*   Function name :   TaskManager
*   Returns :         none       
*   Parameters :      none    
*   Purpose :         Диспетчер задач ОС. Выбирает из очереди задачи и отправляет на выполнение.       
****************************************************************************/
inline void TaskManager(void)
{
  uint8_t index;
  TPTR GoToTask = Idle;		                        // Инициализируем переменные

  // Как видишь, тут есть указатель Idle - ведущий на процедуру простоя ядра.
  // На нее можно повесить что нибудь совсем фоновое, например отладочные примочки =)  
  // И локальная переменная-указатель GoToTask куда мы будем жрать адреса переходов

  __disable_interrupt();			        // Запрещаем прерывания!!!

  // Запрещаем прерывания!!! Это макрос. Поэтому без ; в конце. 
  // Почему не CLI()? Это команда AVR, а я хотел сделать максимально
  // платформонезависимый диспетчер. Прерывания надо запрещать потому, что
  // Идет обращение к глобальной очереди диспетчера. Ее могут менять и прерывания
  // Поэтому заботимся об атомарности операции. 

  GoToTask = TaskQueue[0];		                // Хватаем первое значение из очереди

  if (GoToTask == Idle)			                // Если там пусто
  {
    __enable_interrupt();			        // Разрешаем прерывания
    (Idle)(); 				                // Переходим на обработку пустого цикла
  }
  else
  {
    for (index = 0; index != TaskQueueSize; index++)    // В противном случае сдвигаем всю очередь
    {
      TaskQueue[index] = TaskQueue[index + 1];
    }
    TaskQueue[TaskQueueSize] = Idle;		        // В последнюю запись пихаем затычку
    __enable_interrupt();			        // Разрешаем прерывания
    (GoToTask)();				        // Переходим к задаче
  }
}


/**************************************************************************
*   Function name :   TimerService
*   Returns :                
*   Parameters :          
*   Purpose :         Служба таймеров ядра.
*   NOTE:             Должна вызываться из прерывания раз в 1мс. Хотя время можно варьировать в зависимости от задачи
*                     To DO: Привести к возможности загружать произвольную очередь таймеров. Тогда можно будет создавать их целую прорву. 
*                     А также использовать эту функцию произвольным образом. 
*                     В этом случае не забыть добавить проверку прерывания.
****************************************************************************/
inline void TimerService(void)
{
  uint8_t index;

  for (index = 0; index != MainTimerQueueSize + 1; index++)// Прочесываем очередь таймеров
  {
    if (MainTimer[index].GoToTask == Idle) continue;    // Если нашли пустышку - щелкаем следующую итерацию
    if (MainTimer[index].Time != 1)		        // Если таймер не выщелкал, то щелкаем еще раз. 
    {				                        // To Do: Вычислить по тактам, что лучше !=1 или !=0. 
      MainTimer[index].Time--;	                        // Уменьшаем число в ячейке если не конец.
    }
    else
    {
      SetTask(MainTimer[index].GoToTask);               // Дощелкали до нуля? Пихаем в очередь задачу
      MainTimer[index].GoToTask = Idle;                 // А в ячейку пишем затычку
    }
  }
}
